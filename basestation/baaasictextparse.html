<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>meep meep</title>
    
    <!-- 
  
  this is a CRUDE rushed build of natural lang simple grammar parcing
  
   -->
    <!-- <script src="mission1.js" type="module" defer></script> -->
    <!-- 
    python3 -m http.server 8001 
    You have to shift click reload at times
    -->
    <!-- just cause the console nags error about not having one -->
    <link rel="apple-touch-icon" sizes="180x180" href="./favico/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favico/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favico/favicon-16x16.png">
    <!-- <link rel="manifest" href="/site.webmanifest"> -->

    <link rel="stylesheet" href="./launch.css">

    <!-- idea is to inject here and clear when switching games -->
    <style id="gamestyles" media="screen">
      .fish {
        color: "pwgjpodg";
      }
    </style>
    
    <!-- custom element -->
    <script src="./kindaAI/aiTextInput.js" ></script>
    
    <style media="screen">
      #canvassss{
          /* position: absolute; */
          /* z-index: 0; */
      }
      #magicbox{
        width: 400px;
        /* border: solid 1px green; */
        display: block;
        z-index: 2;
        position: absolute;
        bottom: 0;
        right:0;
      }
    </style>
    
    <!-- TEMP TEMPY TEMP untill we have our own custom component again -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>

    
  </head>

  <body>

    <ai-textinput id="magicbox"></ai-textinput>
    
    <canvas id="canvassss" width="400" height="400"></canvas>

    <!-- 
    <div id="controls222">
      <button class="pause button">ℼ</button>
      <button class="play button">☃</button>
      <button class="step button">☂</button>
    </div>
     -->

    <div id="gamespace"></div>
    <div id="bodyInjectionPointMain">
    </div>


    <script type="text/javascript">

        
    </script>


    <script type="importmap">
			{
				"imports": {
					"game": "./core/game.js",
          "utilites/": "./utilites/",
          "pipelines/": "./core/pipelines/",
          "gl/": "./core/gl/",
          "modules/" : "./modules/",
          "primitives/" : "./primitives/"
				}
			}
		</script>
    
    <script type="module" type="text/javascript">
      import {memory as _m} from './core/memory.js';
      import {BaseStation} from './core/baseStation.js';
      
      window._m = _m;
      
      const cc = document.getElementById("canvassss");
      cc.width = window.innerWidth;
      cc.height = window.innerHeight;
      
      const _b = _m.baseStation = new BaseStation({
        canvasId : "canvassss"
      });
      
      
      import { NotPac } from  "./games/notPac.js";

      _b.insertDisc({game:NotPac});
      
      window.currentPlane = null;
      
      /*
      clearGame()
      spin( addManyPlanes({span:20,width:2,height:2,count:100,colorHex:"random"}) )

      clearGame()
      mockin("10 dogs")
      
      clearGame()
      addPlane({colorHex:0x5c5cff})
      
      window.currentPlane.setColorHex(0xffffff)
      window.currentPlane.loadImage("./sprites/NFT_NFT_NFT_could_this_becat2.png");
      window.currentPlane.position.x= 10
      
      */
      
      window.clearGame = function(){
        _m.baseStation.currentGame.sceneGrapth.reset();
      }
      
      
      window.addPlane = function({width=10, height=10, colorHex=0x0044a3}={}){
        window.currentPlane = _m.baseStation.quickAccess.addPlane({width:width,height:height, colorHex:colorHex});
        return window.currentPlane;
      }
      window.addManyPlanes = function(props){
        return _m.baseStation.quickAccess.addManyPlanes(props);
      }
      // acepts single object or array
      window.spin = function(item){
        return _m.baseStation.quickAccess.spin(item);
      }
      window.fly = function(item){
        return _m.baseStation.quickAccess.fly(item);
      }
      
      window.mockin = function(phrase){
        const aa = phrase.split(" ");
        let yy = addManyPlanes({span:+aa[0],width:2,height:2,count:100,colorHex:"random"})
        yy.map(x=>{
          x.loadImage("./sprites/NFT_NFT_NFT_could_this_becat2.png");
          // x.setColorHex(0xffffff)
        })
      }
      
      
      
      
      

    </script>
    
    <script>
    console.log("lil gui TEMP!!");
    var GUI = lil.GUI;
    const gui = new GUI();
    const __dats = {
      x : 0,
      y : 0,
      z : 148, // backing up in +z it seems
      rz : 0,
      ry : 1.33831847042925,
      fov : 129,
      near : 1,
      far : 2000,
      x2 : 1,
      s2 : 1,
      r2x : 0,
      r2y : 0,
      r2z : 0,
      speed : 1,
      radius : 12,
      theta : 0
    }
    gui.add( __dats, 'x', -400, 400 );
    gui.add( __dats, 'y', -400, 400 );
    gui.add( __dats, 'z', -1000, 1000 );
    // gui.add( __dats, 'rz', 0, Math.PI*2 );
    gui.add( __dats, 'ry', 0, Math.PI*2 );
    // gui.add( __dats, 'fov', 0, Math.PI*2 );
    gui.add( __dats, 'fov', 0, 360 );
    gui.add( __dats, 'speed', 0, 4 );
    gui.add( __dats, 'radius', 0, 800 );
    gui.add( __dats, 'theta', 0, Math.PI*4 );
    
    // gui.add( __dats, 'near', 0, 200 );
    // gui.add( __dats, 'far', 0, 2000 );
    // gui.add( __dats, 'x2', 0, 400 );
    // gui.add( __dats, 's2', 0.0001, 4 );
    // gui.add( __dats, 'r2x', 0, Math.PI*4 );
    // gui.add( __dats, 'r2y', 0, Math.PI*4 );
    // gui.add( __dats, 'r2z', 0, Math.PI*4 );

    </script>
    
    
    <!-- handle tools space -->
    <script type="text/javascript">
      
      const magicbox = document.getElementById("magicbox");
      magicbox.addEventListener("send",(ev)=>{
        console.log("have : ", ev.detail);
        const magicspeel = ev.detail;
        // if (magicspeel === "neat!") {
        //   clearGame()
        //   spin( addManyPlanes({span:20,width:2,height:2,count:100,colorHex:"random"}) )
        // }
        // else if(magicspeel !== ""){
        //   eval(magicspeel);
        // }
        
        clearGame()
        
        // startParse("10 birds flying around a dog");
        // debugger
        
        let aa = magicspeel.split(".");
        for (var i = 0; i < aa.length; i++) {
          startParse(aa[i]);
        }
        
        // startParse(magicspeel);
        // addPlane({colorHex:0x5c5cff})
      });
      
      
      
      
      // PASTED IN CODE HASTE WITH!!
      
      

// here we see that we CAN get a working nesting composition
// BUTTTTTT its very ridgid
// and holding references is fiddly
// around( fly(buildA(bird, 4, birds)), buildA(dog, 2, dogs) )


function buildArrayOfObjects(objectFunc, count = 0) {
  const yy = [];
  let _count = 0;
  if (count < -1) _count = 0;
  for (var i = 0; i < count; i++) {
    yy.push(objectFunc())
  };
  console.log("build array");
  return yy;
}


class ConceptWord{
  needs = ""; // change this to an array later
  count = 0;
  constructor({type="",needs="",count=0,check,build,imageURL}={}){
    this.needs = needs;
    this.count = count;
    this.type = type;
    if(this.check) this.check = check;
    if(this.build) this.build = build;
    this.imageURL = imageURL;
  }
  check(){}
  build(){}
}


var urlNames = {
  cat : "./sprites/NFT_NFT_NFT_could_this_becat2.png",
  cats : "./sprites/NFT_NFT_NFT_could_this_becat2.png",
  birds : "./sprites/NFT_cash_oranges_bird.png",
  birds : "./sprites/NFT_cash_oranges_bird.png",
  dog : "./sprites/dog1.png",
  
}

// references the global funtions ecs's
var verbActions = {
  // flying : fly(item.objects[i])
  flying : function (item) {
    fly(item)
  },
  spinning : function (item) {
    spin(item)
  },
}


class MockPlane {
  isPlane = true;
  constructor(src){
    if (urlNames["src"]) {
      console.log(urlNames["src"]);
    }
    else {
      console.log("??¿¿ no url");
    }
    console.log("built mock plane");
  }
}

function mockFlying(item) {
  item.flying = true;
  console.log("built mock flying");
}
function mockAdverb(item) {
  item.adverb = true;
  console.log("built mock adverb");
}


class CheapPool extends Array{
  add(item){
    this.push(item);
  }
  remove(item){
    const index = this.indexOf(item);
    if(index > -1){
      this.splice(index,1);
    }
  }
}

var mockFactories = {
  
  // builds an array of object its placed
  number : new ConceptWord({
    count:10, needs:"noun",
    check : function (item) {
      // if(item.type === "noun"){
      if(item.type === this.needs){
        let yy = this.build(item);
        return {data:yy, finished:true, kind:"objectsArray"}
      }
      return {data:null, finished:false}
    },
    build : function(item){
      let yy = [];
      for (var i = 0; i < this.count; i++) {
        
        yy.push(item.action.build(item))
        item.objects = yy; // hard assign of 3d objects for now
      }
      
      return yy;
    }  
  }),
  
  // builds a Plane()
  noun : new ConceptWord({
    check : function (item) {
      return {data:null, finished:true}
    },
    build : function(item){
      // const yy = new MockPlane(url)
      // debugger
      const yy = addPlane({colorHex:0x5c5cff})
      yy.setColorHex(0xffffff);
      if (item.url) {
        console.log("item.url", item.url);
        yy.loadImage(item.url)
      }
      return yy;
    }
  }),
  
  // adds properties to object
  verb : new ConceptWord({
    needs:"noun",
    type:"verb",
    check : function (item) {
      // if(item.type === "noun"){
      if(item.type === this.needs){
        this.build(item)
        return {data:item, finished:true}
      }
      return {data:null, finished:false}
    },
    // 
    
    build : function(item){
      console.log("cant put verb selector in here properly");
      // mockFlying(item)
      // debugger
      if (item.objects) {
        for (var i = 0; i < item.objects.length; i++) {
          // spin(item.objects[i])
          if (this.verbActionName && verbActions[this.verbActionName]) {
            verbActions[this.verbActionName](item.objects[i])  
          }
          
          // fly(item.objects[i])
        }
      }
      console.log("this wont work right now cause its a complex object");
      // spin(item)
    }  
  }),
  
  // adds properties to object
  adverb : new ConceptWord({
    needs:"verb",
    check : function (item) {
      // if(item.type === "verb"){
      if(item.type === this.needs){
        this.build(item)
        return {data:item, finished:true}
      }
      return {data:null, finished:false}
    },
    build : function(item){
      mockAdverb(item)
    }  
  }),
  
  
  
}

var mockDictionary = {
  // word has primitive type
  "number": {"type":"determiner"},
  "bird" : {"type":"noun", url:"./sprites/NFT_NFT_NFT_could_this_becat2.png"},
  "birds" : {"type":"noun", url:"./sprites/NFT_NFT_NFT_could_this_becat2.png"},
  "cat" : {"type":"noun", url:"./sprites/NFT_NFT_NFT_could_this_becat2.png"},
  "cats" : {"type":"noun", url:"./sprites/NFT_NFT_NFT_could_this_becat2.png"},
  "flying" : {"type":"verb"},
  "spinning" : {"type":"verb"},
  "around" : {"type":"adverb"},
  "dog" : {"type":"noun"},
  "dogs" : {"type":"noun"}
}

function isNumber(strWord) {
  if(isNaN(strWord)) return false;
  return true;
}


class DataBlock{
  // [ {type:"noun", word:"bird", action: tableItem } ]
  finished = false;
  constructor({type,word,action,url}){
    this.type = type;
    this.word = word;
    this.action = action;
    this.url = url;
  }
}

function buildClassActionsJoinList(phrase) {
  // returns array
  // [ DataBlock(), DataBlock() ]
  
  // tableItem here is a matching name of the type which does stuff
  // skips any word not in list, BUT might shoudl not

  var wordsA = phrase.split(" ");
  // use findClassificationIndex here later
  
  let yy = [];
  for (var i = 0; i < wordsA.length; i++) {
    const word = wordsA[i];
    // number is special since its unsigned infinite
    if(isNumber(word)){
      yy.push(new DataBlock({type:"number",word:word, action:mockFactories["number"]}))
    }
    else if (mockDictionary[word] && mockFactories[ mockDictionary[word].type ] ) {
      // >>>>>
      let url = urlNames[word];
      yy.push(new DataBlock({type:mockDictionary[word].type, word:word, action: mockFactories[ mockDictionary[word].type ], url:url }))
    }
  }
  return yy;
}


function startParse(phrase) {
  
  let scene = [];
  let pool = new CheapPool();
  
  let dataArray = buildClassActionsJoinList(phrase)
  var queueA = new Queue();
  // debugger
  // this is a crappy patch
  for (var i = 0; i < dataArray.length; i++) {
    if(dataArray[i].type === "number"){
      dataArray[i].action.count = +dataArray[i].word;
    }
    if(dataArray[i].type === "verb"){
      // debugger
      dataArray[i].action.verbActionName = dataArray[i].word;
    }
  }
  // verbActions
  // fly(item.objects[i])
  

  const index = 0;
  const lim = dataArray.length;
  
  recursiveFn({lim:lim, index:index, dataArray:dataArray, queue:queueA, scene:scene, pool:pool});
}





// words
function recursiveFn({lim, index, dataArray, queue, scene, pool}) {
    console.log("aaa", index);
    if (index === lim) {
      console.log("out 111");
      return;
    }


    let selected = dataArray[index];
    let holdSelected = null;

    // we need to have control of the order and specials data
    // shelving it away in queue with pointer logic is annoying

    // previous words tests
    for (var ii = queue.items.length-1; ii >= 0; ii--) {
      let aa = queue.items[ii];
      let bb = aa.action.check(selected);
      if (bb.finished) {
        if(bb.kind === "objectsArray"){
          for (var rr = 0; rr < bb.data.length; rr++) {
            // debugger
            scene.push(bb.data[rr])
            bb.data[rr].randomPosition(-20,20)
            bb.data[rr].position.z = 0;
          }
        }
        queue.items.splice(ii,1);
      }
      
    }

    
    // current word test
    if (selected.action.needs !== "") {
      if (queue.stock.length > 0) {
        let picked = null;
        for (var ii = queue.stock.length-1; ii >= 0; ii--) {
          if (selected.action.needs === queue.stock[ii].type) {
            picked = queue.stock[ii];
            break;
          }
        }
        if (picked) {
          let yy = selected.action.check(picked);
          // debugger
          if(yy.finished){
            if(yy.kind === "objectsArray"){
              for (var rr = 0; rr < yy.data.length; rr++) {
                scene.push(yy.data[rr])
                // debugger
              }
            }
            selected.finished = true;
          }
        }
        
      }
      if(selected.finished == false){
          queue.addItem(selected);
      }
    }
    
    // singular noun self builds
    // cant figure out
    // else if (selected.action.needs === "" && selected.type === "noun") {
    // 
    // }
    
    
    // Missing dog!!!!
    
    // add no matter what
    queue.addStock(selected);
    
    console.log(dataArray[index].type);
    
    // recurrrrrsion
    index++;
    recursiveFn({lim:lim, index:index, dataArray:dataArray, queue:queue, scene:scene, pool:pool});
    console.log("bbbb", index);
}



class Queue{
  items = new CheapPool();
  stock = new CheapPool();
  
  // nextItem(){
  //   if (this.items.length > 0) {
  //     let pick = this.items[this.items.length-1];
  //     return pick;
  //     // let mm = this.items[i].action.check(dataItem);
  //   }
  // }
  // 
  // nextStock(){
  //   if (this.stock.length > 0) {
  //     let pick = this.stock[this.stock.length-1];
  //     return pick;
  //     // let mm = this.items[i].action.check(dataItem);
  //   }
  // }
  
  
  addItem(item){
    this.items.add(item);
  }
  removeItem(item){
    this.items.remove(item);
  }
  
  addStock(item){
    this.stock.add(item);
  }
  removeStock(item){
    this.stock.remove(item);
  }
  
  // NOT sure about this...
  // flush(){
  //   for (var i = this.items.length-1; i >= 0; i--) {
  //     if(this.items[i].finished === true){
  //       this.items[i].finished = true;
  //       console.log(this.items[i]);
  //       this.items.splice(i,1);
  //     }
  //   }
  // }
  
}

      
      
      
      
      
      
      
      
      
      
      
        
    </script>
    
    
  </body>
</html>
